ğŸŸ¦ Original matn (ruscha):
Ğ¡ÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒÑÑ‚ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°, Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ½Ñ‹Ğµ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ Ñ‡Ñ‚ĞµĞ½Ğ¸Ñ Ğ¸Ğ»Ğ¸ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ´Ğ»Ñ
Ğ·Ğ°Ğ¿Ğ¸ÑĞ¸. Ğ¢Ğ¾ ĞµÑÑ‚ÑŒ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ñ‚Ğ°ĞºĞ¸Ğ¼, Ñ‡Ñ‚Ğ¾ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ ÑƒĞ·Ğ½Ğ°Ñ‚ÑŒ ĞµĞ³Ğ¾
Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ, Ğ½Ğ¾ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¿Ñ€Ğ¸ÑĞ²Ğ¾Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ñƒ. Ğ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ
Ğ¸ Ğ½Ğ°Ğ¾Ğ±Ğ¾Ñ€Ğ¾Ñ‚: ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ñƒ Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¿Ñ€Ğ¸ÑĞ²Ğ¾Ğ¸Ñ‚ÑŒ Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ, Ğ½Ğ¾ Ğ½ĞµĞ»ÑŒĞ·Ñ ÑƒĞ·Ğ½Ğ°Ñ‚ÑŒ
Ğ·Ğ½Ğ°Ñ‡ĞµĞ½Ğ¸Ğµ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ°.

âœ… Oâ€˜zbekchasi va tushuntirishi:
ğŸ”¹ Faqat oâ€˜qish yoki faqat yozish uchun moâ€˜ljallangan xossalar mavjud.
ğŸ”¸ Yaâ€™ni xossa shunday boâ€˜lishi mumkin: uning qiymatini oâ€˜qish mumkin, lekin unga yangi qiymat berib boâ€˜lmaydi (readonly).
ğŸ”¸ Yoki aksincha: unga qiymat berish mumkin, lekin uning qiymatini oâ€˜qib boâ€˜lmaydi (write-only).

ğŸ§  Tushuncha:
C# da xossalar ikki qismdan iborat boâ€˜ladi â€” get (oâ€˜qish) va set (yozish).
Siz faqat get yozsangiz â€” bu faqat oâ€˜qiladigan xossa, faqat set yozsangiz â€” bu faqat yoziladigan xossa boâ€˜ladi.

ğŸŸ¦ Davomi:
Ğ¡Ğ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ Ğ¸ Ğ¾Ñ‚ĞºÑ€Ñ‹Ñ‚Ñ‹Ğ¼, Ğ¸ Ğ·Ğ°ĞºÑ€Ñ‹Ñ‚Ñ‹Ğ¼ (Ğ¿Ñ€Ğ¸ Ğ¾Ğ¿Ğ¸ÑĞ°Ğ½Ğ¸Ğ¸ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ° Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ ĞºĞ»ÑÑ‡ĞµĞ²Ğ¾Ğµ ÑĞ»Ğ¾Ğ²Ğ¾, Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑÑÑ‰ĞµĞµ ÑƒÑ€Ğ¾Ğ²ĞµĞ½ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°), Ğ° Ñ‚Ğ°ĞºĞ¶Ğµ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ±Ñ‹Ñ‚ÑŒ ÑÑ‚Ğ°Ñ‚Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼.

âœ… Oâ€˜zbekchasi va tushuntirishi:
ğŸ”¹ Xossa ochiq (public) ham, yopiq (private yoki protected) ham boâ€˜lishi mumkin.
ğŸ”¸ Xossaning kirish darajasini aniqlash uchun kirish operatorlari (access modifiers) ishlatiladi: public, private, protected, internal va hokazo.
ğŸ”¸ Shuningdek, xossa statik (static) boâ€˜lishi ham mumkin, yaâ€™ni u klassga bogâ€˜liq boâ€˜ladi, obâ€™ektga emas.

ğŸ§  Tushuncha:

csharp
ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
public string Name { get; set; }      // ochiq xossa
private int Age { get; set; }         // yopiq xossa
public static string AppName { get; set; }  // statik xossa
ğŸŸ¦ Davomi:
ĞŸĞ¾ÑĞºĞ¾Ğ»ÑŒĞºÑƒ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ½Ğµ Ğ¾Ğ¿Ñ€ĞµĞ´ĞµĞ»ÑĞµÑ‚ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸ Ğ¸ Ğ½Ğµ ÑĞ²ÑĞ·Ğ°Ğ½Ğ¾
Ñ Ğ¾Ğ±Ğ»Ğ°ÑÑ‚ÑŒÑ Ğ¿Ğ°Ğ¼ÑÑ‚Ğ¸, Ñ‚Ğ¾ ÑĞ²Ğ¾Ğ¹ÑÑ‚Ğ²Ğ¾ Ğ½ĞµĞ»ÑŒĞ·Ñ Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ÑŒ Ñ Ğ¸Ğ´ĞµĞ½Ñ‚Ğ¸Ñ„Ğ¸ĞºĞ°Ñ‚Ğ¾Ñ€Ğ°Ğ¼Ğ¸ ref Ğ¸ out.

âœ… Oâ€˜zbekchasi va tushuntirishi:
ğŸ”¹ Xossa oâ€˜zining alohida xotira hududiga ega emas va u toâ€˜gâ€˜ridan-toâ€˜gâ€˜ri xotira bilan bogâ€˜liq emas,
ğŸ”¸ Shuning uchun xossani ref yoki out bilan ishlatib boâ€˜lmaydi.

ğŸ§  Tushuncha:

ref va out â€” bu aniq xotira manziliga ishlov beruvchi uslublar.

Xossa esa orqasida funksiya/avtomatik kod boâ€˜lishi mumkin, u xotira joylashuvi bilan bogâ€˜liq emas.

Shu sababli quyidagi kod xatolik beradi:

csharp
ĞšĞ¾Ğ¿Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
Ğ ĞµĞ´Ğ°ĞºÑ‚Ğ¸Ñ€Ğ¾Ğ²Ğ°Ñ‚ÑŒ
public string Name { get; set; }

void Print(ref string name)
{
    // bu xato: xossa ref bilan chaqirib boâ€˜lmaydi
    Print(ref person.Name);  // âŒ XATOLIK
}
ğŸ”š XULOSA:
Narsa	Tushuntiruv
Faqat oâ€˜qiladigan xossa	get bor, set yoâ€˜q
Faqat yoziladigan xossa	set bor, get yoâ€˜q
Kirish darajalari	public, private, protected, internal
Statik xossa	static kalit soâ€˜z bilan belgilanadi
ref / out ishlatilmasligi	Xossa aniq xotira manzili emas, faqat qiymat beradi

Agar xohlasangiz, bu jihatlarning har biriga kod misollar yozib beraman.
Keyingi bosqichga oâ€˜tamizmi? Yoki readonly va write-only xossalarni real kodda koâ€˜rsataymi?

Indeksator â€” bu klassning maxsus aâ€™zosi boâ€˜lib, uning mavjudligi klass obyektlarini indekslash imkonini beradi.

Agar biz obyektni indekslayapmiz desak, bu shuni anglatadiki: obyekt nomidan keyin kvadrat qavs ichida indeks (yoki indekslar) beriladi â€” albatta, bunda bunday ifoda mantiqan maâ€™noga ega boâ€˜lishi kerak.

Demak, agar siz klassda indeksator eâ€™lon qilsangiz, u holda obyektdan massiv kabi foydalanishingiz mumkin. Bu esa juda qulay va istiqbolli imkoniyatdir.
ğŸ”µ Indeksator qanday ishlaydi?
Indeksator bilan ishlashda ikkita holat mavjud:

Qiymatni oâ€˜qish: yaâ€™ni, obj[3] orqali qiymat olish. Bunda get aksessor ishlaydi.

Qiymat tayinlash: yaâ€™ni, obj[3] = 45; orqali qiymat yozish. Bunda set aksessor ishlaydi.

Bu holatlar xossalar (properties) kabi ishlaydi, faqat indeksatorda qoâ€˜shimcha ravishda indeks ham ishtirok etadi.


public tip this[tur indeks]
{
    get
    {
        // indeks boâ€˜yicha qiymatni qaytarish
    }
    set
    {
        // indeks boâ€˜yicha yangi qiymatni yozish (value yordamida)
    }
}


Izoh:
tip â€” indekslashda qaytariladigan yoki yoziladigan qiymat turi (masalan, int, string).

this â€” bu indeksator faqat shu klassga tegishli ekanini bildiradi.

indeks â€” massivga oâ€˜xshab, oâ€˜sha indeks orqali ishlash.

value â€” set aksessorida tashqaridan kelgan qiymat.

ğŸ”µ Muhim eslatmalar:
Indeksatorlar koâ€˜pincha int indeks bilan ishlatiladi, lekin bu shart emas. string yoki boshqa turdagi indekslar ham boâ€˜lishi mumkin.

Indeksatorlar overload qilinishi mumkin (yaâ€™ni, bir klassda bir nechta indeksator boâ€˜lishi mumkin â€” indekslar soni yoki turi bilan farqlanadi).

Indeksatorlar static boâ€˜la olmaydi.

ref yoki out bilan ishlatilmaydi.

ğŸ”µ this kalit soâ€˜zi haqida
this â€” bu klass ichida obyektning oâ€˜ziga murojaat qilish uchun ishlatiladi.

Indeksatorda this orqali obj[...] usulidagi yozuvlar amalga oshiriladi.

class MyClass
{
    private int[] data = new int[10];

    public int this[int index]
    {
        get
        {
            return data[index];
        }
        set
        {
            data[index] = value;
        }
    }
}
__________________________________________
MyClass obj = new MyClass();
obj[0] = 5;         // set ishlaydi
Console.Write(obj[0]);  // get ishlaydi
ğŸ”µ Yakuniy xulosa:
Indeksator â€” bu sizga obyektdan massivdek foydalanish imkonini beradigan vosita.
U xossalar kabi ishlaydi, lekin qoâ€˜shimcha ravishda indeks ishtirok etadi.
Bu kodni sodda, oâ€˜qilishi oson, va qulay qiladi.

Agar xohlasangiz, hozir real kod misoli bilan amaliy koâ€˜rsatib ham beraman. Yoki shuni oâ€˜zingiz yozib koâ€˜rishni xohlaysizmi?


